\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[pdftex]{graphicx}
\usepackage{fancyhdr}
\usepackage{lscape}
\usepackage{color}
\usepackage{qtree}
\usepackage[english]{babel}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage{listings}
\usepackage{color}
\usepackage{changepage}
\usepackage[margin=1in]{geometry}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
\usepackage[final]{pdfpages} 
 
 \lstdefinestyle{mystyle}{
 	backgroundcolor=\color{backcolour},   
 	commentstyle=\color{codegreen},
 	keywordstyle=\color{magenta},
 	numberstyle=\tiny\color{codegray},
 	stringstyle=\color{codepurple},
 	basicstyle=\footnotesize,
 	breakatwhitespace=false,         
 	breaklines=true,                 
 	captionpos=b,                    
 	keepspaces=true,                 
 	numbers=left,                    
 	numbersep=5pt,                  
 	showspaces=false,                
 	showstringspaces=false,
 	showtabs=false,                  
 	tabsize=2
 }
 
\lstset{
	style=mystyle,
	inputencoding=utf8,
	extendedchars=true,
	literate={á}{{\'a}}1 {ã}{{\~a}}1 {é}{{\'e}}1,
	escapechar=\&
}
\title{Algorithmique et structures de données : Mission 2 (produit)}
\date{07 octobre 2014}
\author{Groupe 1.2: Ivan Ahad - Jérôme Bertaux - Rodolphe Cambier \\ 
	Baptiste Degryse - Wojciech Grynczel - Charles Jaquet}



\begin{document}
\maketitle
\paragraph{Question 1}
La profondeur est le nombre de parents qu’un noeud comporte. La racine est donc de profondeur 0, et ses enfants sont de profondeur 1. La hauteur est le nombre maximum de générations en dessous du noeud. Une feuille a une hauteur de 0, et les autre noeuds ont la hauteur de leur enfant le plus haut+1. Le niveau n est l’ensemble des nœuds de profondeur n. Ces notions ne dépendent pas du style d’arbre, elles s'appliquent aux arbres en général car il suffit d’avoir la notion de racine, feuille, enfant et parent pour pouvoir appliquer ces définitions. Ces notions ne dépendent pas de la structure de données utilisée car la représentation ne dépend pas de l’implémentation.

\paragraph{Question 2}

\paragraph{Question 3}

\paragraph{Question 4}

Une implémentation d’un arbre par une structure chaînée signifie que pour réaliser l’arbre on utilise une structure chaînée. C’est-à-dire que chaque noeud de l’arbre contient une référence vers son noeud parent, vers son noeud enfant de gauche et vers son noeud enfant de droite en plus de contenir l’élément. L’arbre contient la référence du noeud racine de l’arbre et la taille ce celui-ci. 

Cette notion de structure chaînée est plus générale qu’une liste chaînée car chaque noeud de l’arbre contient plus d’une référence. Dans un arbre à partir d’un noeud il est toujours possible de remonter vers le noeud parent ou alors descendre vers un des noeuds enfants alors que dans une liste chaînée on ne peut que se déplacer vers le noeud suivant. Donc la recherche d’un noeud s’effectue plus rapidement dans un arbre en structure chaînée.

Les points communs entre liste et structure chaînée :

- L’objet général (Arbre et liste) contiennent tous les deux la taille et une référence vers le noeud racine.

- Dans les deux implémentations les noeuds contiennent au minimum une référence vers un autre noeud.

La classe qui implémente un arbre par une structure chaînée est LinkedBinaryTree (DSAJ-6 page 297). Il est possible d’utiliser une implémentation utilisant une liste chaînée seulement si on utilise une liste double chaînée.

\paragraph{Question 5}

Dans la majorité des cas de parcours, cela ne pose pas de problème, car on parcours l'arbre depuis la racine jusqu'aux feuilles. Cela peut cependant être handicapant dans certaines situations. Dans le cas où l'on voudrait, par exemple, parcourir tous les noeuds de l'arbre situés à un même niveau, ne pas avoir la possibilité de remonter peut poser problème et ralentir fortement le processus.

Pour réaliser la méthode parent, on peut faire comme suit: Garder le pointeur sur le noeud dont on veut le parent.
Vérifier si ce noeud n'est pas le root, auquel cas on retourne null.
Parcourir l'arbre noeud par noeud, en vérifiant pour chacun si un de ses fils n'est pas le noeud dont on cherche le parent. 
On finit donc par trouver le parent du noeud de départ.Puisqu'il faut, au pire, parcourir tout l'arbre pour trouver le père, on a une complexité en O(n).

\paragraph{Question 6 (Charles Jacquet)}


Définition de la classe LinkedRBinaryTree qui implémente l'interface RBinaryTree:

\includepdf[pages=1-4]{LinkedBinaryTree.pdf}

\paragraph{Question 7\\	Une expression arithmétique peut contenir les quatre opérateurs fondamentaux
	$ +,-,*,/ $ et des scalaires, comme par exemple : $ 3 * 10 - 2/4 $. Une expression
	analytique, telle que $ x^{2}+x$ $ sin $ $ x-3 $ peut contenir également des variables $ x,y,... $ ,
	d’autres opérateurs comme la fonction puissance entière $ ˆ $ ou d’autres fonctions
	mathématiques comme $ sin $ ou $ cos $.\\}

	\textbf{
	Une expression arithmétique peut être représentée par un arbre.
	Quelles sont les caractéristiques de cet arbre ?\\}
Arbre binaire est un arbre avec une racine, et où chacun des nœuds possède : 
\begin{itemize}
	\item soit aucun successeur, 
	\item soit un successeur, à gauche ou à droite, 
	\item soit deux successeurs. 
\end{itemize}

\textbf{Pourquoi cette représentation est-elle utile ?}\\
//TODO
 Techniques for parsing the common infix notation (where the operator is typically between two operands) and converting it into a binary tree are well known. Expressions are converted into binary trees, where unary operators (i.e., the unary minus or the sine function) are converted into degenerate nodes in the binary trees, with a single son. See Fig. 1 for the arithmetic expression of sin .
\textbf{Citez deux exemples de manipulation d’une expression arithmétique et exprimez comment ces manipulations sont mise en oeuvre à l’aide de cette représentation + Exemple !!!!!!!.}

\[ ((1+2)*(3-4)) \]
\Tree[.* [.+ [.1 ][.2 ]][.- [.3 ][.4 ]]]

\[ (3+(4*5)) \]
\Tree[.+ [.3 ][.* [.4 ][.5 ]]]

\textbf{Quelles sont les caractéristiques supplémentaires pour un arbre représentant une expression analytique ?.}\\
Une expression analytique peut contenir des opérations unaires, par exemple : \\
\Tree[.+ [.log [.y ]][./ [.x ][.1.2 ]]]

\paragraph{Question 8}
\begin{figure}
\includegraphics[scale=0.6]{inorder_traversal.png}
\caption{inorder traversal path (from Data Structure And Algorithms in Java p 424)}
\label{inorder}
\end{figure}

C'est le parcours "inorder traversal" d'un arbre binaire qui permet de parcourir l'arbre dans le bon sens. Voir figure \ref{inorder}

\begin{lstlisting}[language=Java]
public String toString(){
if ( T.isExternal(v) )
	return v.getElement().toString();
else
	return "("+ v.left() + v.getElement() + v.right() +")";
}
\end{lstlisting}

\paragraph{Question 9 (Charles Jacquet)}
Représentation des opérations de dérivation:

\begin{enumerate}
\item Addition: \newline
dérivée$\left( \Tree[.+ 4 X^2 ] \right) \rightarrow \left( \Tree[.+ dérivée(4) dérivée(X^2) ] \right) \rightarrow \left( \Tree[.+ 0 2X ] \right) $
\item Soustraction: \\

dérivée$\left( \Tree[.- 4 X^2 ] \right) \rightarrow \left( \Tree[.- dérivée(4) dérivée(X^2) ] \right) \rightarrow \left( \Tree[.- 0 2X ] \right) $

\item Multiplication: \\

dérivée$\left( \Tree[.* 4 X^2 ] \right) \rightarrow 
\left( \Tree[.+ [.* dérivée(4) X^2 ] [.* 4 dérivée(X^2) ] ] \right)
\left( \Tree[.+ [.* 0 X^2 ] [.* 4 2X ] ] \right)
 $

\item Division:  \\

dérivée$\left( \Tree[./ 4 X^2 ] \right) \rightarrow 
\left( \Tree[./ [.+ [.* dérivée(4) X^2 ] [.* 4 dérivée(X^2) ] ] (x^2)^2 ] \right) \rightarrow 
\left( \Tree[./ [.+ [.* 0 X^2 ] [.* 4 2X ] ] (x^4 ] \right)
 $

\end{enumerate}

\end{document}
